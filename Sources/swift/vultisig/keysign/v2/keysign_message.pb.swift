// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vultisig/keysign/v2/keysign_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct VSKeysignMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var serviceName: String = String()

  public var encryptionKeyHex: String = String()

  public var keysignPayload: VSKeysignPayload {
    get {return _keysignPayload ?? VSKeysignPayload()}
    set {_keysignPayload = newValue}
  }
  /// Returns true if `keysignPayload` has been explicitly set.
  public var hasKeysignPayload: Bool {return self._keysignPayload != nil}
  /// Clears the value of `keysignPayload`. Subsequent reads from it will return its default value.
  public mutating func clearKeysignPayload() {self._keysignPayload = nil}

  public var useVultisigRelay: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keysignPayload: VSKeysignPayload? = nil
}

public struct VSEVMTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: VSCoin {
    get {return _storage._coin ?? VSCoin()}
    set {_uniqueStorage()._coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return _storage._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {_uniqueStorage()._coin = nil}

  public var toAddress: String {
    get {return _storage._toAddress}
    set {_uniqueStorage()._toAddress = newValue}
  }

  public var toAmount: String {
    get {return _storage._toAmount}
    set {_uniqueStorage()._toAmount = newValue}
  }

  public var maxFeePerGasWei: String {
    get {return _storage._maxFeePerGasWei}
    set {_uniqueStorage()._maxFeePerGasWei = newValue}
  }

  public var priorityFee: String {
    get {return _storage._priorityFee}
    set {_uniqueStorage()._priorityFee = newValue}
  }

  public var nonce: Int64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var gasLimit: String {
    get {return _storage._gasLimit}
    set {_uniqueStorage()._gasLimit = newValue}
  }

  public var memo: String {
    get {return _storage._memo ?? String()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {_uniqueStorage()._memo = nil}

  public var erc20ApprovePayload: VSErc20ApprovePayload {
    get {return _storage._erc20ApprovePayload ?? VSErc20ApprovePayload()}
    set {_uniqueStorage()._erc20ApprovePayload = newValue}
  }
  /// Returns true if `erc20ApprovePayload` has been explicitly set.
  public var hasErc20ApprovePayload: Bool {return _storage._erc20ApprovePayload != nil}
  /// Clears the value of `erc20ApprovePayload`. Subsequent reads from it will return its default value.
  public mutating func clearErc20ApprovePayload() {_uniqueStorage()._erc20ApprovePayload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct VSCosmosTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: VSCoin {
    get {return _coin ?? VSCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var toAddress: String = String()

  public var toAmount: String = String()

  public var accountNumber: UInt64 = 0

  public var sequence: UInt64 = 0

  public var gas: UInt64 = 0

  public var transactionType: VSCosmosTransaction.TransactionType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TransactionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case vote // = 1
    case proposal // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .vote
      case 2: self = .proposal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .vote: return 1
      case .proposal: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _coin: VSCoin? = nil
}

#if swift(>=4.2)

extension VSCosmosTransaction.TransactionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [VSCosmosTransaction.TransactionType] = [
    .unspecified,
    .vote,
    .proposal,
  ]
}

#endif  // swift(>=4.2)

public struct VSTHORChainTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fromCoin: VSCoin {
    get {return _fromCoin ?? VSCoin()}
    set {_fromCoin = newValue}
  }
  /// Returns true if `fromCoin` has been explicitly set.
  public var hasFromCoin: Bool {return self._fromCoin != nil}
  /// Clears the value of `fromCoin`. Subsequent reads from it will return its default value.
  public mutating func clearFromCoin() {self._fromCoin = nil}

  public var toAddress: String = String()

  public var toAmount: String = String()

  public var accountNumber: UInt64 = 0

  public var sequence: UInt64 = 0

  public var fee: UInt64 = 0

  /// probably don't need it , because when `to_address` is empty , it's a deposit , still keep it to make it specific
  public var isDeposit: String = String()

  public var memo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fromCoin: VSCoin? = nil
}

public struct VSUTXOTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: VSCoin {
    get {return _coin ?? VSCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var toAddress: String = String()

  public var toAmount: String = String()

  public var byteFee: String = String()

  public var sendMaxAmount: Bool = false

  public var memo: String {
    get {return _memo ?? String()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {self._memo = nil}

  public var utxoInfo: [VSUtxoInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: VSCoin? = nil
  fileprivate var _memo: String? = nil
}

public struct VSSolanaTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: VSCoin {
    get {return _coin ?? VSCoin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {self._coin = nil}

  public var toAddress: String = String()

  public var toAmount: String = String()

  public var recentBlockHash: String = String()

  public var priorityFee: String = String()

  public var fromTokenAssociatedAddress: String {
    get {return _fromTokenAssociatedAddress ?? String()}
    set {_fromTokenAssociatedAddress = newValue}
  }
  /// Returns true if `fromTokenAssociatedAddress` has been explicitly set.
  public var hasFromTokenAssociatedAddress: Bool {return self._fromTokenAssociatedAddress != nil}
  /// Clears the value of `fromTokenAssociatedAddress`. Subsequent reads from it will return its default value.
  public mutating func clearFromTokenAssociatedAddress() {self._fromTokenAssociatedAddress = nil}

  public var toTokenAssociatedAddress: String {
    get {return _toTokenAssociatedAddress ?? String()}
    set {_toTokenAssociatedAddress = newValue}
  }
  /// Returns true if `toTokenAssociatedAddress` has been explicitly set.
  public var hasToTokenAssociatedAddress: Bool {return self._toTokenAssociatedAddress != nil}
  /// Clears the value of `toTokenAssociatedAddress`. Subsequent reads from it will return its default value.
  public mutating func clearToTokenAssociatedAddress() {self._toTokenAssociatedAddress = nil}

  public var memo: String {
    get {return _memo ?? String()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {self._memo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coin: VSCoin? = nil
  fileprivate var _fromTokenAssociatedAddress: String? = nil
  fileprivate var _toTokenAssociatedAddress: String? = nil
  fileprivate var _memo: String? = nil
}

public struct VSPolkadotTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coin: VSCoin {
    get {return _storage._coin ?? VSCoin()}
    set {_uniqueStorage()._coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  public var hasCoin: Bool {return _storage._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  public mutating func clearCoin() {_uniqueStorage()._coin = nil}

  public var toAddress: String {
    get {return _storage._toAddress}
    set {_uniqueStorage()._toAddress = newValue}
  }

  public var toAmount: String {
    get {return _storage._toAmount}
    set {_uniqueStorage()._toAmount = newValue}
  }

  public var recentBlockHash: String {
    get {return _storage._recentBlockHash}
    set {_uniqueStorage()._recentBlockHash = newValue}
  }

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var currentBlockNumber: String {
    get {return _storage._currentBlockNumber}
    set {_uniqueStorage()._currentBlockNumber = newValue}
  }

  public var specVersion: UInt32 {
    get {return _storage._specVersion}
    set {_uniqueStorage()._specVersion = newValue}
  }

  public var transactionVersion: UInt32 {
    get {return _storage._transactionVersion}
    set {_uniqueStorage()._transactionVersion = newValue}
  }

  public var genesisHash: String {
    get {return _storage._genesisHash}
    set {_uniqueStorage()._genesisHash = newValue}
  }

  public var memo: String {
    get {return _storage._memo ?? String()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {_uniqueStorage()._memo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SwapInfo is mostly for display purpose
public struct VSSwapInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var toCoin: VSCoin {
    get {return _toCoin ?? VSCoin()}
    set {_toCoin = newValue}
  }
  /// Returns true if `toCoin` has been explicitly set.
  public var hasToCoin: Bool {return self._toCoin != nil}
  /// Clears the value of `toCoin`. Subsequent reads from it will return its default value.
  public mutating func clearToCoin() {self._toCoin = nil}

  public var provider: String = String()

  public var slippage: String = String()

  public var fee: String = String()

  public var targetAmount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toCoin: VSCoin? = nil
}

public struct VSKeysignPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: OneOf_Transaction? {
    get {return _storage._transaction}
    set {_uniqueStorage()._transaction = newValue}
  }

  public var evmTransaction: VSEVMTransaction {
    get {
      if case .evmTransaction(let v)? = _storage._transaction {return v}
      return VSEVMTransaction()
    }
    set {_uniqueStorage()._transaction = .evmTransaction(newValue)}
  }

  public var cosmosTransaction: VSCosmosTransaction {
    get {
      if case .cosmosTransaction(let v)? = _storage._transaction {return v}
      return VSCosmosTransaction()
    }
    set {_uniqueStorage()._transaction = .cosmosTransaction(newValue)}
  }

  public var thorchainTransaction: VSTHORChainTransaction {
    get {
      if case .thorchainTransaction(let v)? = _storage._transaction {return v}
      return VSTHORChainTransaction()
    }
    set {_uniqueStorage()._transaction = .thorchainTransaction(newValue)}
  }

  public var utxoTransaction: VSUTXOTransaction {
    get {
      if case .utxoTransaction(let v)? = _storage._transaction {return v}
      return VSUTXOTransaction()
    }
    set {_uniqueStorage()._transaction = .utxoTransaction(newValue)}
  }

  public var solanaTransaction: VSSolanaTransaction {
    get {
      if case .solanaTransaction(let v)? = _storage._transaction {return v}
      return VSSolanaTransaction()
    }
    set {_uniqueStorage()._transaction = .solanaTransaction(newValue)}
  }

  public var polkadotTransaction: VSPolkadotTransaction {
    get {
      if case .polkadotTransaction(let v)? = _storage._transaction {return v}
      return VSPolkadotTransaction()
    }
    set {_uniqueStorage()._transaction = .polkadotTransaction(newValue)}
  }

  /// when swap_info is not empty , then the pair device shoudl treat it as a swap
  /// 1. Show swap verify screen
  /// 2. for EVM chain , need to construct a generic smart contract transaction
  public var swapInfo: VSSwapInfo {
    get {return _storage._swapInfo ?? VSSwapInfo()}
    set {_uniqueStorage()._swapInfo = newValue}
  }
  /// Returns true if `swapInfo` has been explicitly set.
  public var hasSwapInfo: Bool {return _storage._swapInfo != nil}
  /// Clears the value of `swapInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSwapInfo() {_uniqueStorage()._swapInfo = nil}

  public var vaultPublicKeyEcdsa: String {
    get {return _storage._vaultPublicKeyEcdsa}
    set {_uniqueStorage()._vaultPublicKeyEcdsa = newValue}
  }

  public var vaultLocalPartyID: String {
    get {return _storage._vaultLocalPartyID}
    set {_uniqueStorage()._vaultLocalPartyID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Transaction: Equatable {
    case evmTransaction(VSEVMTransaction)
    case cosmosTransaction(VSCosmosTransaction)
    case thorchainTransaction(VSTHORChainTransaction)
    case utxoTransaction(VSUTXOTransaction)
    case solanaTransaction(VSSolanaTransaction)
    case polkadotTransaction(VSPolkadotTransaction)

  #if !swift(>=4.1)
    public static func ==(lhs: VSKeysignPayload.OneOf_Transaction, rhs: VSKeysignPayload.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.evmTransaction, .evmTransaction): return {
        guard case .evmTransaction(let l) = lhs, case .evmTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cosmosTransaction, .cosmosTransaction): return {
        guard case .cosmosTransaction(let l) = lhs, case .cosmosTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thorchainTransaction, .thorchainTransaction): return {
        guard case .thorchainTransaction(let l) = lhs, case .thorchainTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.utxoTransaction, .utxoTransaction): return {
        guard case .utxoTransaction(let l) = lhs, case .utxoTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.solanaTransaction, .solanaTransaction): return {
        guard case .solanaTransaction(let l) = lhs, case .solanaTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.polkadotTransaction, .polkadotTransaction): return {
        guard case .polkadotTransaction(let l) = lhs, case .polkadotTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension VSKeysignMessage: @unchecked Sendable {}
extension VSEVMTransaction: @unchecked Sendable {}
extension VSCosmosTransaction: @unchecked Sendable {}
extension VSCosmosTransaction.TransactionType: @unchecked Sendable {}
extension VSTHORChainTransaction: @unchecked Sendable {}
extension VSUTXOTransaction: @unchecked Sendable {}
extension VSSolanaTransaction: @unchecked Sendable {}
extension VSPolkadotTransaction: @unchecked Sendable {}
extension VSSwapInfo: @unchecked Sendable {}
extension VSKeysignPayload: @unchecked Sendable {}
extension VSKeysignPayload.OneOf_Transaction: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vultisig.keysign.v2"

extension VSKeysignMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeysignMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "service_name"),
    4: .standard(proto: "encryption_key_hex"),
    5: .standard(proto: "keysign_payload"),
    6: .standard(proto: "use_vultisig_relay"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.encryptionKeyHex) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._keysignPayload) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.useVultisigRelay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 2)
    }
    if !self.encryptionKeyHex.isEmpty {
      try visitor.visitSingularStringField(value: self.encryptionKeyHex, fieldNumber: 4)
    }
    try { if let v = self._keysignPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.useVultisigRelay != false {
      try visitor.visitSingularBoolField(value: self.useVultisigRelay, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSKeysignMessage, rhs: VSKeysignMessage) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.encryptionKeyHex != rhs.encryptionKeyHex {return false}
    if lhs._keysignPayload != rhs._keysignPayload {return false}
    if lhs.useVultisigRelay != rhs.useVultisigRelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSEVMTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EVMTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "max_fee_per_gas_wei"),
    5: .standard(proto: "priority_fee"),
    6: .same(proto: "nonce"),
    7: .standard(proto: "gas_limit"),
    8: .same(proto: "memo"),
    9: .standard(proto: "erc20_approve_payload"),
  ]

  fileprivate class _StorageClass {
    var _coin: VSCoin? = nil
    var _toAddress: String = String()
    var _toAmount: String = String()
    var _maxFeePerGasWei: String = String()
    var _priorityFee: String = String()
    var _nonce: Int64 = 0
    var _gasLimit: String = String()
    var _memo: String? = nil
    var _erc20ApprovePayload: VSErc20ApprovePayload? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _coin = source._coin
      _toAddress = source._toAddress
      _toAmount = source._toAmount
      _maxFeePerGasWei = source._maxFeePerGasWei
      _priorityFee = source._priorityFee
      _nonce = source._nonce
      _gasLimit = source._gasLimit
      _memo = source._memo
      _erc20ApprovePayload = source._erc20ApprovePayload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._coin) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._toAddress) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._toAmount) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._maxFeePerGasWei) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._priorityFee) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._nonce) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._gasLimit) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._erc20ApprovePayload) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._coin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._toAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toAddress, fieldNumber: 2)
      }
      if !_storage._toAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toAmount, fieldNumber: 3)
      }
      if !_storage._maxFeePerGasWei.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxFeePerGasWei, fieldNumber: 4)
      }
      if !_storage._priorityFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._priorityFee, fieldNumber: 5)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nonce, fieldNumber: 6)
      }
      if !_storage._gasLimit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gasLimit, fieldNumber: 7)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._erc20ApprovePayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSEVMTransaction, rhs: VSEVMTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._toAddress != rhs_storage._toAddress {return false}
        if _storage._toAmount != rhs_storage._toAmount {return false}
        if _storage._maxFeePerGasWei != rhs_storage._maxFeePerGasWei {return false}
        if _storage._priorityFee != rhs_storage._priorityFee {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._gasLimit != rhs_storage._gasLimit {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._erc20ApprovePayload != rhs_storage._erc20ApprovePayload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSCosmosTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CosmosTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "account_number"),
    5: .same(proto: "sequence"),
    6: .same(proto: "gas"),
    7: .standard(proto: "transaction_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.transactionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 5)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 6)
    }
    if self.transactionType != .unspecified {
      try visitor.visitSingularEnumField(value: self.transactionType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSCosmosTransaction, rhs: VSCosmosTransaction) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.transactionType != rhs.transactionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSCosmosTransaction.TransactionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSACTION_TYPE_UNSPECIFIED"),
    1: .same(proto: "TRANSACTION_TYPE_VOTE"),
    2: .same(proto: "TRANSACTION_TYPE_PROPOSAL"),
  ]
}

extension VSTHORChainTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".THORChainTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "account_number"),
    5: .same(proto: "sequence"),
    6: .same(proto: "fee"),
    7: .standard(proto: "is_deposit"),
    8: .same(proto: "memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromCoin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.isDeposit) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 5)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 6)
    }
    if !self.isDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.isDeposit, fieldNumber: 7)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSTHORChainTransaction, rhs: VSTHORChainTransaction) -> Bool {
    if lhs._fromCoin != rhs._fromCoin {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.isDeposit != rhs.isDeposit {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSUTXOTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UTXOTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "byte_fee"),
    5: .standard(proto: "send_max_amount"),
    6: .same(proto: "memo"),
    7: .standard(proto: "utxo_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.byteFee) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sendMaxAmount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._memo) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.utxoInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 3)
    }
    if !self.byteFee.isEmpty {
      try visitor.visitSingularStringField(value: self.byteFee, fieldNumber: 4)
    }
    if self.sendMaxAmount != false {
      try visitor.visitSingularBoolField(value: self.sendMaxAmount, fieldNumber: 5)
    }
    try { if let v = self._memo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.utxoInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxoInfo, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSUTXOTransaction, rhs: VSUTXOTransaction) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.byteFee != rhs.byteFee {return false}
    if lhs.sendMaxAmount != rhs.sendMaxAmount {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.utxoInfo != rhs.utxoInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSSolanaTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SolanaTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "recent_block_hash"),
    5: .standard(proto: "priority_fee"),
    6: .standard(proto: "from_token_associated_address"),
    7: .standard(proto: "to_token_associated_address"),
    8: .same(proto: "memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.recentBlockHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.priorityFee) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._fromTokenAssociatedAddress) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._toTokenAssociatedAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._memo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 3)
    }
    if !self.recentBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.recentBlockHash, fieldNumber: 4)
    }
    if !self.priorityFee.isEmpty {
      try visitor.visitSingularStringField(value: self.priorityFee, fieldNumber: 5)
    }
    try { if let v = self._fromTokenAssociatedAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._toTokenAssociatedAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._memo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSSolanaTransaction, rhs: VSSolanaTransaction) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.recentBlockHash != rhs.recentBlockHash {return false}
    if lhs.priorityFee != rhs.priorityFee {return false}
    if lhs._fromTokenAssociatedAddress != rhs._fromTokenAssociatedAddress {return false}
    if lhs._toTokenAssociatedAddress != rhs._toTokenAssociatedAddress {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSPolkadotTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolkadotTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "to_amount"),
    4: .standard(proto: "recent_block_hash"),
    5: .same(proto: "nonce"),
    6: .standard(proto: "current_block_number"),
    7: .standard(proto: "spec_version"),
    8: .standard(proto: "transaction_version"),
    9: .standard(proto: "genesis_hash"),
    10: .same(proto: "memo"),
  ]

  fileprivate class _StorageClass {
    var _coin: VSCoin? = nil
    var _toAddress: String = String()
    var _toAmount: String = String()
    var _recentBlockHash: String = String()
    var _nonce: UInt64 = 0
    var _currentBlockNumber: String = String()
    var _specVersion: UInt32 = 0
    var _transactionVersion: UInt32 = 0
    var _genesisHash: String = String()
    var _memo: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _coin = source._coin
      _toAddress = source._toAddress
      _toAmount = source._toAmount
      _recentBlockHash = source._recentBlockHash
      _nonce = source._nonce
      _currentBlockNumber = source._currentBlockNumber
      _specVersion = source._specVersion
      _transactionVersion = source._transactionVersion
      _genesisHash = source._genesisHash
      _memo = source._memo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._coin) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._toAddress) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._toAmount) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._recentBlockHash) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._nonce) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currentBlockNumber) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._specVersion) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._transactionVersion) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._genesisHash) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._coin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._toAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toAddress, fieldNumber: 2)
      }
      if !_storage._toAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toAmount, fieldNumber: 3)
      }
      if !_storage._recentBlockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recentBlockHash, fieldNumber: 4)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 5)
      }
      if !_storage._currentBlockNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentBlockNumber, fieldNumber: 6)
      }
      if _storage._specVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._specVersion, fieldNumber: 7)
      }
      if _storage._transactionVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._transactionVersion, fieldNumber: 8)
      }
      if !_storage._genesisHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisHash, fieldNumber: 9)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSPolkadotTransaction, rhs: VSPolkadotTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coin != rhs_storage._coin {return false}
        if _storage._toAddress != rhs_storage._toAddress {return false}
        if _storage._toAmount != rhs_storage._toAmount {return false}
        if _storage._recentBlockHash != rhs_storage._recentBlockHash {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._currentBlockNumber != rhs_storage._currentBlockNumber {return false}
        if _storage._specVersion != rhs_storage._specVersion {return false}
        if _storage._transactionVersion != rhs_storage._transactionVersion {return false}
        if _storage._genesisHash != rhs_storage._genesisHash {return false}
        if _storage._memo != rhs_storage._memo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSSwapInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_coin"),
    2: .same(proto: "provider"),
    3: .same(proto: "slippage"),
    4: .same(proto: "fee"),
    5: .standard(proto: "target_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._toCoin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.slippage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._toCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if !self.slippage.isEmpty {
      try visitor.visitSingularStringField(value: self.slippage, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 4)
    }
    if !self.targetAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.targetAmount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSSwapInfo, rhs: VSSwapInfo) -> Bool {
    if lhs._toCoin != rhs._toCoin {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.slippage != rhs.slippage {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.targetAmount != rhs.targetAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VSKeysignPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeysignPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evm_transaction"),
    2: .standard(proto: "cosmos_transaction"),
    3: .standard(proto: "thorchain_transaction"),
    4: .standard(proto: "utxo_transaction"),
    5: .standard(proto: "solana_transaction"),
    6: .standard(proto: "polkadot_transaction"),
    20: .standard(proto: "swap_info"),
    31: .standard(proto: "vault_public_key_ecdsa"),
    32: .standard(proto: "vault_local_party_id"),
  ]

  fileprivate class _StorageClass {
    var _transaction: VSKeysignPayload.OneOf_Transaction?
    var _swapInfo: VSSwapInfo? = nil
    var _vaultPublicKeyEcdsa: String = String()
    var _vaultLocalPartyID: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _swapInfo = source._swapInfo
      _vaultPublicKeyEcdsa = source._vaultPublicKeyEcdsa
      _vaultLocalPartyID = source._vaultLocalPartyID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: VSEVMTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .evmTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .evmTransaction(v)
          }
        }()
        case 2: try {
          var v: VSCosmosTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .cosmosTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .cosmosTransaction(v)
          }
        }()
        case 3: try {
          var v: VSTHORChainTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .thorchainTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .thorchainTransaction(v)
          }
        }()
        case 4: try {
          var v: VSUTXOTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .utxoTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .utxoTransaction(v)
          }
        }()
        case 5: try {
          var v: VSSolanaTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .solanaTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .solanaTransaction(v)
          }
        }()
        case 6: try {
          var v: VSPolkadotTransaction?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .polkadotTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .polkadotTransaction(v)
          }
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._swapInfo) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._vaultPublicKeyEcdsa) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._vaultLocalPartyID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._transaction {
      case .evmTransaction?: try {
        guard case .evmTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .cosmosTransaction?: try {
        guard case .cosmosTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .thorchainTransaction?: try {
        guard case .thorchainTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .utxoTransaction?: try {
        guard case .utxoTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .solanaTransaction?: try {
        guard case .solanaTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .polkadotTransaction?: try {
        guard case .polkadotTransaction(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      try { if let v = _storage._swapInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._vaultPublicKeyEcdsa.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vaultPublicKeyEcdsa, fieldNumber: 31)
      }
      if !_storage._vaultLocalPartyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vaultLocalPartyID, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VSKeysignPayload, rhs: VSKeysignPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._swapInfo != rhs_storage._swapInfo {return false}
        if _storage._vaultPublicKeyEcdsa != rhs_storage._vaultPublicKeyEcdsa {return false}
        if _storage._vaultLocalPartyID != rhs_storage._vaultLocalPartyID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
